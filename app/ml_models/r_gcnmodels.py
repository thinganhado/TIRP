# -*- coding: utf-8 -*-
"""R-GCNMODELS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ge_tryLY37Cpe74P5XWYYbxuvFt-VXI9
"""

import torch
from torch_geometric.data import HeteroData
import pandas as pd
import numpy as np
from torch_geometric.nn import RGCNConv
import torch.nn.functional as F
from itertools import combinations
from sklearn.utils import shuffle
from torch import nn
from tqdm import tqdm

# Load student survey responses (features)
student_data = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="responses")

participant_data = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="participants")

# Load student relationships (edges)
friends = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="net_0_Friends")

influence = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="net_1_Influential")

meaningful = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="net_2_Feedback")

Moretime = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="net_3_MoreTime")

Advice = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="net_4_Advice")

Disrespect = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="net_5_Disrespect")

Activity = pd.read_excel("student_data/Student Survey - Jan.xlsx", sheet_name="net_affiliation_0_SchoolActivit")

student_ids = student_data["Participant-ID"].values

# Remove self-loops from the DataFrame
friends = friends[friends["Source"] != friends["Target"]]
influence = influence[influence["Source"] != influence["Target"]]
meaningful = meaningful[meaningful["Source"] != meaningful["Target"]]
Moretime = Moretime[Moretime["Source"] != Moretime["Target"]]
Advice = Advice[Advice["Source"] != Advice["Target"]]
Disrespect = Disrespect[Disrespect["Source"] != Disrespect["Target"]]
Activity = Activity[Activity["Source"] != Activity["Target"]]

# Participant_data cleaning
participant_data.columns = participant_data.columns.str.strip()  # Fix spaces
participant_data['Perc_Academic'] = participant_data['Perc_Academic'].fillna(participant_data['Perc_Academic'].mean())

relation_types = {
    'friends': friends,
    'influence': influence,
    'meaningful': meaningful,
    'moretime': Moretime,
    'advice': Advice,
    'disrespect': Disrespect
}


feature_cols = ['pwi_wellbeing', 'Intelligence1', 'Intelligence2', 'GrowthMindset', 'comfortable', 'future', 'bullying']
student_features = student_data[['Participant-ID'] + feature_cols]  # Include student ID for mapping

# na vals
student_features.loc[:, feature_cols] = student_features[feature_cols].fillna(student_features[feature_cols].mean())

# Initialize hetero graph
data = HeteroData()

# Add nodes (students)
data['student'].x = torch.tensor(student_features[feature_cols].values, dtype=torch.float)
participant_id_to_idx = {pid: idx for idx, pid in enumerate(student_features['Participant-ID'])}

# Add edges for each relationship type
for relation_name, df in relation_types.items():
    edge_index = df[df['Source'].isin(participant_id_to_idx) & df['Target'].isin(participant_id_to_idx)]
    src = edge_index['Source'].map(participant_id_to_idx)
    tgt = edge_index['Target'].map(participant_id_to_idx)
    edge_tensor = torch.tensor([src.values, tgt.values], dtype=torch.long)
    data['student', relation_name, 'student'].edge_index = edge_tensor

# Save for future use
# torch.save(data, "R-GCN_files/hetero_graph.pt")
# print("âœ… Heterogeneous graph saved as 'hetero_graph.pt'")

## CLASS SET-UP FOR RGCN

class RGCNClassifier(torch.nn.Module):
    def __init__(self, in_channels, hidden_channels, num_classes, num_relations):
        super(RGCNClassifier, self).__init__()
        self.conv1 = RGCNConv(in_channels, hidden_channels, num_relations)
        self.conv2 = RGCNConv(hidden_channels, num_classes, num_relations)

    def forward(self, x, edge_index, edge_type):
        x = self.conv1(x, edge_index, edge_type)
        x = F.relu(x)
        x = self.conv2(x, edge_index, edge_type)
        return x

## CLASS SET-UP FOR LINK PREDICTION

class RGCNLinkPredictor(torch.nn.Module):
    def __init__(self, in_channels, hidden_channels, num_relations):
        super(RGCNLinkPredictor, self).__init__()
        self.rgcn1 = RGCNConv(in_channels, hidden_channels, num_relations)
        self.rgcn2 = RGCNConv(hidden_channels, hidden_channels, num_relations)
        self.dropout = nn.Dropout(p=0.3)  # or 0.2
        
        # Updated classifier: deeper and more expressive

        self.classifier = nn.Sequential(
            nn.Linear(hidden_channels * 4, 128),
            nn.ReLU(),
            nn.Dropout(p=0.3),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 1)
        )


    def forward(self, x, edge_index, edge_type):
        x = self.rgcn1(x, edge_index, edge_type)
        x = F.relu(x)
        x = self.rgcn2(x, edge_index, edge_type)
        return x  # Node embeddings

    def predict(self, embeddings, edge_index):
        src = embeddings[edge_index[:, 0]]
        tgt = embeddings[edge_index[:, 1]]
        
        # Richer edge representation
        edge_repr = torch.cat([src, tgt, torch.abs(src - tgt), src * tgt], dim=1)
        
        return self.classifier(edge_repr).squeeze()  # Raw logits

# Load the graph and models
# hetero_graph = torch.load("R-GCN_files/hetero_graph.pt", weights_only=False)
hetero_graph = data
student_x = hetero_graph['student'].x
edge_index_combined = torch.cat([hetero_graph.edge_index_dict[rel] for rel in hetero_graph.edge_index_dict], dim=1)

edge_type = []
for rel, edge_index in hetero_graph.edge_index_dict.items():
    rel_type_index = list(hetero_graph.edge_types).index(rel)
    edge_type.extend([rel_type_index] * edge_index.shape[1])
edge_type = torch.tensor(edge_type)

# Load saved models

model_influential = torch.load("R-GCN_files/model_influential.pt", weights_only=False)
model_isolated = torch.load("R-GCN_files/model_isolated.pt", weights_only=False)
model_friendship_link = torch.load("R-GCN_files/model_friendship_link.pt", weights_only=False)


# Set models to eval
model_influential.eval()
model_isolated.eval()


# Predict
with torch.no_grad():
    out_influential = torch.sigmoid(model_influential(student_x, edge_index_combined, edge_type)).squeeze()
    out_isolated = torch.sigmoid(model_isolated(student_x, edge_index_combined, edge_type)).squeeze()

# Create DataFrame
student_scores_df = pd.DataFrame({
    "student_index": list(range(student_x.shape[0])),
    "influential_score": out_influential.tolist(),
    "isolated_score": out_isolated.tolist()
})

# Display it
student_scores_df.to_excel("R-GCN_files/student_scores.xlsx", index=False)

model_friendship_link.eval()

num_students = student_x.shape[0]
friendship_scores = []

batch_size = 1024
pairs = []

# Generate all student pairs (excluding self-loops)
for i in range(num_students):
    for j in range(i + 1, num_students):
        pairs.append([i, j])

# Run in batches
with torch.no_grad():
    for i in tqdm(range(0, len(pairs), batch_size)):
        batch_pairs = torch.tensor(pairs[i:i+batch_size], dtype=torch.long)
        embeddings = model_friendship_link(student_x, edge_index_combined, edge_type)
        # Apply sigmoid to get scores between 0 and 1
        raw_scores = model_friendship_link.predict(embeddings, batch_pairs)
        scores = torch.sigmoid(raw_scores).cpu().numpy()
        friendship_scores.extend(zip(batch_pairs.numpy().tolist(), scores.tolist()))

# Convert to DataFrame
friend_df = pd.DataFrame(friendship_scores, columns=["student_pair", "friendship_score"])
friend_df[['student1', 'student2']] = pd.DataFrame(friend_df['student_pair'].tolist(), index=friend_df.index)
friend_df.drop(columns=['student_pair'], inplace=True)

# Optional: Sort by highest scores
friend_df = friend_df.sort_values(by='friendship_score', ascending=False)

# Show top scores
friend_df.to_excel("R-GCN_files/friendship_scores.xlsx", index=False)